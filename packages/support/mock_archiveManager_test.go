// Code generated by mockery v2.42.1. DO NOT EDIT.

package support

import (
	archive "github.com/cloudogu/cesapp-lib/archive"
	mock "github.com/stretchr/testify/mock"

	time "time"
)

// mockArchiveManager is an autogenerated mock type for the archiveManager type
type mockArchiveManager struct {
	mock.Mock
}

type mockArchiveManager_Expecter struct {
	mock *mock.Mock
}

func (_m *mockArchiveManager) EXPECT() *mockArchiveManager_Expecter {
	return &mockArchiveManager_Expecter{mock: &_m.Mock}
}

// AddContentAsFile provides a mock function with given fields: content, fileNameInArchive
func (_m *mockArchiveManager) AddContentAsFile(content string, fileNameInArchive string) error {
	ret := _m.Called(content, fileNameInArchive)

	if len(ret) == 0 {
		panic("no return value specified for AddContentAsFile")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(content, fileNameInArchive)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// mockArchiveManager_AddContentAsFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddContentAsFile'
type mockArchiveManager_AddContentAsFile_Call struct {
	*mock.Call
}

// AddContentAsFile is a helper method to define mock.On call
//   - content string
//   - fileNameInArchive string
func (_e *mockArchiveManager_Expecter) AddContentAsFile(content interface{}, fileNameInArchive interface{}) *mockArchiveManager_AddContentAsFile_Call {
	return &mockArchiveManager_AddContentAsFile_Call{Call: _e.mock.On("AddContentAsFile", content, fileNameInArchive)}
}

func (_c *mockArchiveManager_AddContentAsFile_Call) Run(run func(content string, fileNameInArchive string)) *mockArchiveManager_AddContentAsFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *mockArchiveManager_AddContentAsFile_Call) Return(_a0 error) *mockArchiveManager_AddContentAsFile_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *mockArchiveManager_AddContentAsFile_Call) RunAndReturn(run func(string, string) error) *mockArchiveManager_AddContentAsFile_Call {
	_c.Call.Return(run)
	return _c
}

// AddContentAsFileWithModifiedDate provides a mock function with given fields: content, fileNameInArchive, modified
func (_m *mockArchiveManager) AddContentAsFileWithModifiedDate(content string, fileNameInArchive string, modified time.Time) error {
	ret := _m.Called(content, fileNameInArchive, modified)

	if len(ret) == 0 {
		panic("no return value specified for AddContentAsFileWithModifiedDate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, time.Time) error); ok {
		r0 = rf(content, fileNameInArchive, modified)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// mockArchiveManager_AddContentAsFileWithModifiedDate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddContentAsFileWithModifiedDate'
type mockArchiveManager_AddContentAsFileWithModifiedDate_Call struct {
	*mock.Call
}

// AddContentAsFileWithModifiedDate is a helper method to define mock.On call
//   - content string
//   - fileNameInArchive string
//   - modified time.Time
func (_e *mockArchiveManager_Expecter) AddContentAsFileWithModifiedDate(content interface{}, fileNameInArchive interface{}, modified interface{}) *mockArchiveManager_AddContentAsFileWithModifiedDate_Call {
	return &mockArchiveManager_AddContentAsFileWithModifiedDate_Call{Call: _e.mock.On("AddContentAsFileWithModifiedDate", content, fileNameInArchive, modified)}
}

func (_c *mockArchiveManager_AddContentAsFileWithModifiedDate_Call) Run(run func(content string, fileNameInArchive string, modified time.Time)) *mockArchiveManager_AddContentAsFileWithModifiedDate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(time.Time))
	})
	return _c
}

func (_c *mockArchiveManager_AddContentAsFileWithModifiedDate_Call) Return(_a0 error) *mockArchiveManager_AddContentAsFileWithModifiedDate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *mockArchiveManager_AddContentAsFileWithModifiedDate_Call) RunAndReturn(run func(string, string, time.Time) error) *mockArchiveManager_AddContentAsFileWithModifiedDate_Call {
	_c.Call.Return(run)
	return _c
}

// AddFileToArchive provides a mock function with given fields: file
func (_m *mockArchiveManager) AddFileToArchive(file archive.File) error {
	ret := _m.Called(file)

	if len(ret) == 0 {
		panic("no return value specified for AddFileToArchive")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(archive.File) error); ok {
		r0 = rf(file)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// mockArchiveManager_AddFileToArchive_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddFileToArchive'
type mockArchiveManager_AddFileToArchive_Call struct {
	*mock.Call
}

// AddFileToArchive is a helper method to define mock.On call
//   - file archive.File
func (_e *mockArchiveManager_Expecter) AddFileToArchive(file interface{}) *mockArchiveManager_AddFileToArchive_Call {
	return &mockArchiveManager_AddFileToArchive_Call{Call: _e.mock.On("AddFileToArchive", file)}
}

func (_c *mockArchiveManager_AddFileToArchive_Call) Run(run func(file archive.File)) *mockArchiveManager_AddFileToArchive_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(archive.File))
	})
	return _c
}

func (_c *mockArchiveManager_AddFileToArchive_Call) Return(_a0 error) *mockArchiveManager_AddFileToArchive_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *mockArchiveManager_AddFileToArchive_Call) RunAndReturn(run func(archive.File) error) *mockArchiveManager_AddFileToArchive_Call {
	_c.Call.Return(run)
	return _c
}

// AddFilesToArchive provides a mock function with given fields: files, closeAfterFinish
func (_m *mockArchiveManager) AddFilesToArchive(files []archive.File, closeAfterFinish bool) error {
	ret := _m.Called(files, closeAfterFinish)

	if len(ret) == 0 {
		panic("no return value specified for AddFilesToArchive")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func([]archive.File, bool) error); ok {
		r0 = rf(files, closeAfterFinish)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// mockArchiveManager_AddFilesToArchive_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddFilesToArchive'
type mockArchiveManager_AddFilesToArchive_Call struct {
	*mock.Call
}

// AddFilesToArchive is a helper method to define mock.On call
//   - files []archive.File
//   - closeAfterFinish bool
func (_e *mockArchiveManager_Expecter) AddFilesToArchive(files interface{}, closeAfterFinish interface{}) *mockArchiveManager_AddFilesToArchive_Call {
	return &mockArchiveManager_AddFilesToArchive_Call{Call: _e.mock.On("AddFilesToArchive", files, closeAfterFinish)}
}

func (_c *mockArchiveManager_AddFilesToArchive_Call) Run(run func(files []archive.File, closeAfterFinish bool)) *mockArchiveManager_AddFilesToArchive_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]archive.File), args[1].(bool))
	})
	return _c
}

func (_c *mockArchiveManager_AddFilesToArchive_Call) Return(_a0 error) *mockArchiveManager_AddFilesToArchive_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *mockArchiveManager_AddFilesToArchive_Call) RunAndReturn(run func([]archive.File, bool) error) *mockArchiveManager_AddFilesToArchive_Call {
	_c.Call.Return(run)
	return _c
}

// Close provides a mock function with given fields:
func (_m *mockArchiveManager) Close() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// mockArchiveManager_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type mockArchiveManager_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
func (_e *mockArchiveManager_Expecter) Close() *mockArchiveManager_Close_Call {
	return &mockArchiveManager_Close_Call{Call: _e.mock.On("Close")}
}

func (_c *mockArchiveManager_Close_Call) Run(run func()) *mockArchiveManager_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *mockArchiveManager_Close_Call) Return(_a0 error) *mockArchiveManager_Close_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *mockArchiveManager_Close_Call) RunAndReturn(run func() error) *mockArchiveManager_Close_Call {
	_c.Call.Return(run)
	return _c
}

// GetContent provides a mock function with given fields:
func (_m *mockArchiveManager) GetContent() []byte {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetContent")
	}

	var r0 []byte
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	return r0
}

// mockArchiveManager_GetContent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetContent'
type mockArchiveManager_GetContent_Call struct {
	*mock.Call
}

// GetContent is a helper method to define mock.On call
func (_e *mockArchiveManager_Expecter) GetContent() *mockArchiveManager_GetContent_Call {
	return &mockArchiveManager_GetContent_Call{Call: _e.mock.On("GetContent")}
}

func (_c *mockArchiveManager_GetContent_Call) Run(run func()) *mockArchiveManager_GetContent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *mockArchiveManager_GetContent_Call) Return(_a0 []byte) *mockArchiveManager_GetContent_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *mockArchiveManager_GetContent_Call) RunAndReturn(run func() []byte) *mockArchiveManager_GetContent_Call {
	_c.Call.Return(run)
	return _c
}

// SaveArchiveAsFile provides a mock function with given fields: archivePath
func (_m *mockArchiveManager) SaveArchiveAsFile(archivePath string) error {
	ret := _m.Called(archivePath)

	if len(ret) == 0 {
		panic("no return value specified for SaveArchiveAsFile")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(archivePath)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// mockArchiveManager_SaveArchiveAsFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SaveArchiveAsFile'
type mockArchiveManager_SaveArchiveAsFile_Call struct {
	*mock.Call
}

// SaveArchiveAsFile is a helper method to define mock.On call
//   - archivePath string
func (_e *mockArchiveManager_Expecter) SaveArchiveAsFile(archivePath interface{}) *mockArchiveManager_SaveArchiveAsFile_Call {
	return &mockArchiveManager_SaveArchiveAsFile_Call{Call: _e.mock.On("SaveArchiveAsFile", archivePath)}
}

func (_c *mockArchiveManager_SaveArchiveAsFile_Call) Run(run func(archivePath string)) *mockArchiveManager_SaveArchiveAsFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *mockArchiveManager_SaveArchiveAsFile_Call) Return(_a0 error) *mockArchiveManager_SaveArchiveAsFile_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *mockArchiveManager_SaveArchiveAsFile_Call) RunAndReturn(run func(string) error) *mockArchiveManager_SaveArchiveAsFile_Call {
	_c.Call.Return(run)
	return _c
}

// newMockArchiveManager creates a new instance of mockArchiveManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func newMockArchiveManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *mockArchiveManager {
	mock := &mockArchiveManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
